<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å…‰å½±æˆ˜æ£‹ v5.0 - æ·±å±‚æ€ç»´</title>
    <style>
      :root {
        --bg-color: #0d1117;
        --panel-bg: #161b22;
        --cell-bg: #21262d;
        --cell-lit: #323842;
        --cell-shadow: #161b22;

        --red-main: #ff7b72;
        --red-dim: rgba(255, 123, 114, 0.2);
        --blue-main: #79c0ff;
        --blue-dim: rgba(121, 192, 255, 0.2);

        --beam-core: #fff;
        --beam-glow: #e3b341;
      }

      body {
        font-family: "Segoe UI", system-ui, sans-serif;
        background: var(--bg-color);
        color: #c9d1d9;
        margin: 0;
        height: 100vh;
        display: flex;
        overflow: hidden;
        user-select: none;
      }

      /* å¸ƒå±€ */
      .layout {
        display: flex;
        width: 100%;
        height: 100%;
      }

      .main-stage {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        background: radial-gradient(
          circle at 50% 50%,
          #1f242c 0%,
          #0d1117 100%
        );
        position: relative;
      }

      .sidebar {
        width: 320px;
        background: var(--panel-bg);
        border-left: 1px solid #30363d;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
        z-index: 20;
      }

      /* æ£‹ç›˜å®¹å™¨ */
      .board-wrap {
        position: relative;
        padding: 8px;
        background: #161b22;
        border-radius: 4px;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
        border: 1px solid #30363d;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(11, 50px);
        grid-template-rows: repeat(11, 50px);
        gap: 1px;
        background: #30363d;
      }

      /* æ ¼å­æ ·å¼ */
      .cell {
        width: 50px;
        height: 50px;
        background: var(--cell-bg);
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background 0.3s ease;
      }

      .cell.lit {
        background: var(--cell-lit);
      }
      .cell.lit::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.05) 0%,
          transparent 70%
        );
      }

      /* é—è¿¹/éšœç¢ */
      .cell.ruin {
        background: #0d1117;
        background-image: repeating-linear-gradient(
          -45deg,
          transparent 0,
          transparent 5px,
          #1c2128 5px,
          #1c2128 10px
        );
      }

      /* ä¸Šä¸€æ­¥æç¤º */
      .cell.last-move {
        box-shadow: inset 0 0 0 2px rgba(231, 195, 75, 0.6);
      }

      /* æ£‹å­ */
      .piece {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 26px;
        position: relative;
        z-index: 10;
        transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        background: #21262d;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }

      .piece.red {
        border: 2px solid var(--red-main);
        color: var(--red-main);
        text-shadow: 0 0 10px var(--red-main);
      }
      .piece.blue {
        border: 2px solid var(--blue-main);
        color: var(--blue-main);
        text-shadow: 0 0 10px var(--blue-main);
      }

      .piece.selected {
        transform: scale(1.15) translateY(-2px);
        z-index: 100;
        background: #fff;
      }
      .piece.red.selected {
        color: var(--red-main);
        border-color: var(--red-main);
      }
      .piece.blue.selected {
        color: var(--blue-main);
        border-color: var(--blue-main);
      }

      /* äº¤äº’æ ‡è®° */
      .marker {
        position: absolute;
        border-radius: 50%;
        pointer-events: none;
        z-index: 15;
      }
      .marker.move {
        width: 12px;
        height: 12px;
        background: rgba(88, 166, 255, 0.6);
        box-shadow: 0 0 8px rgba(88, 166, 255, 0.8);
      }
      .marker.attack {
        width: 44px;
        height: 44px;
        border: 3px solid rgba(248, 81, 73, 0.7);
        animation: pulse 1s infinite;
        border-radius: 8px;
      }

      @keyframes pulse {
        50% {
          opacity: 0.5;
          transform: scale(0.95);
        }
      }

      /* æ¿€å…‰å±‚ */
      .beam-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        filter: drop-shadow(0 0 4px var(--beam-glow));
      }

      /* UI ç»„ä»¶ */
      h1 {
        font-size: 20px;
        margin: 0;
        color: #fff;
        border-bottom: 1px solid #30363d;
        padding-bottom: 16px;
      }

      .status-box {
        background: #0d1117;
        border: 1px solid #30363d;
        border-radius: 6px;
        padding: 16px;
      }
      .status-title {
        font-size: 12px;
        color: #8b949e;
        text-transform: uppercase;
        margin-bottom: 8px;
        display: block;
      }
      .turn-indicator {
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .btn {
        background: #238636;
        color: white;
        border: none;
        padding: 12px;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
        transition: 0.2s;
      }
      .btn:hover {
        background: #2ea043;
      }
      .btn.secondary {
        background: #21262d;
        border: 1px solid #30363d;
        color: #c9d1d9;
      }
      .btn.secondary:hover {
        background: #30363d;
      }

      .mode-switch {
        display: flex;
        gap: 8px;
      }
      .mode-btn {
        flex: 1;
        padding: 8px;
        font-size: 13px;
      }

      /* æ£‹å­è¯¦æƒ… */
      .info-row {
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .info-icon {
        font-size: 32px;
      }
      .buff-tag {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 4px;
        display: inline-block;
        font-weight: bold;
      }
      .buff-good {
        color: #7ee787;
        border: 1px solid #3fb950;
        background: rgba(63, 185, 80, 0.1);
      }
      .buff-bad {
        color: #ff7b72;
        border: 1px solid #f85149;
        background: rgba(248, 81, 73, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="main-stage">
        <div class="board-wrap">
          <div class="board" id="board"></div>
          <svg class="beam-layer" id="beam-layer"></svg>
        </div>
      </div>

      <div class="sidebar">
        <h1>Lumen & Umbra v5.0</h1>

        <div class="mode-switch">
          <button
            class="btn secondary mode-btn"
            id="btn-pvp"
            onclick="switchMode('pvp')"
          >
            åŒäººå¯¹æˆ˜
          </button>
          <button class="btn mode-btn" id="btn-pve" onclick="switchMode('pve')">
            æŒ‘æˆ˜ AI
          </button>
        </div>

        <div class="status-box">
          <span class="status-title">å½“å‰å±€åŠ¿</span>
          <div class="turn-indicator" id="turn-text">ğŸ”´ çº¢æ–¹å›åˆ</div>
          <div
            id="ai-log"
            style="
              font-size: 12px;
              color: #8b949e;
              margin-top: 8px;
              font-family: monospace;
              display: none;
            "
          >
            > ç¥ç»ç½‘ç»œåˆå§‹åŒ–...<br />
            > æ­£åœ¨æ¨¡æ‹Ÿå…‰è·¯...
          </div>
        </div>

        <div
          class="status-box"
          id="info-panel"
          style="display: none; transition: opacity 0.2s"
        >
          <span class="status-title">å•ä½ä¿¡æ¯</span>
          <div class="info-row">
            <div class="info-icon" id="p-icon"></div>
            <div>
              <div id="p-name" style="font-weight: bold; color: #fff"></div>
              <div
                id="p-desc"
                style="font-size: 12px; color: #8b949e; margin: 2px 0"
              ></div>
              <div id="p-status"></div>
            </div>
          </div>
        </div>

        <div style="flex: 1"></div>
        <button class="btn secondary" onclick="resetGame()">é‡ç½®æ£‹ç›˜</button>
      </div>
    </div>

    <script>
      // --- æ¸¸æˆé…ç½® ---
      const BOARD_SIZE = 11;
      const CELL_PX = 50;

      const TYPES = {
        SOURCE: "source", // æ ¸å¿ƒ
        PRISM: "prism", // æ£±é•œ
        SHADOW: "shadow", // å½±è¡Œè€…
        GUARD: "guard", // å…‰å«
        VOID: "void", // è™šç©º
        RUIN: "ruin", // é—è¿¹
      };

      const CONFIG = {
        [TYPES.SOURCE]: {
          icon: "â˜€ï¸",
          name: "æ—¥è½®æ ¸å¿ƒ",
          desc: "èƒœè´Ÿå…³é”®ã€‚å…‰æŸæºå¤´ã€‚",
        },
        [TYPES.PRISM]: {
          icon: "ğŸ’",
          name: "èšç„¦æ£±é•œ",
          desc: "æŠ˜å°„å…‰çº¿ (90Â°)ã€‚",
        },
        [TYPES.SHADOW]: {
          icon: "ğŸ¥·",
          name: "å½±è¡Œè€…",
          desc: "æš—æ€è€…ã€‚æš—å¤„ä¸å¯è¢«å†²é”‹ã€‚",
        },
        [TYPES.GUARD]: {
          icon: "ğŸ›¡ï¸",
          name: "å…‰è€€å«å£«",
          desc: "æˆ˜å£«ã€‚å…‰ä¸­å†²é”‹ï¼Œæš—å¤„æ­¥å…µã€‚",
        },
        [TYPES.VOID]: {
          icon: "â¬›",
          name: "è™šç©ºéšœå£",
          desc: "æ©ä½“ã€‚å®Œå…¨é˜»æŒ¡å…‰çº¿ã€‚",
        },
        [TYPES.RUIN]: {
          icon: "ğŸ›ï¸",
          name: "å¤ä»£é—è¿¹",
          desc: "ä¸­ç«‹éšœç¢ã€‚ä¸å¯ç§»åŠ¨ã€‚",
        },
      };

      // --- å…¨å±€çŠ¶æ€ ---
      let state = {
        board: [], // 11x11 å­˜å‚¨å¯¹è±¡ {type, owner, id}
        lightMap: [], // 11x11 bool
        beams: [], // æ¸²æŸ“ç”¨å…‰æŸæ•°æ®
        turn: "red", // 'red' | 'blue'
        mode: "pve", // 'pvp' | 'pve'
        selected: null, // {r, c}
        lastMove: null, // {fromR, fromC, toR, toC}
        isAiBusy: false,
        gameOver: false,
      };

      // --- æ ¸å¿ƒå¼•æ“ï¼šå…‰ç…§è®¡ç®— (çº¯å‡½æ•°ï¼Œæ–¹ä¾¿ AI æ¨¡æ‹Ÿ) ---
      function computeLight(boardData) {
        let light = Array(BOARD_SIZE)
          .fill(0)
          .map(() => Array(BOARD_SIZE).fill(false));
        let beams = [];
        let rays = [];

        // 1. æ”¶é›†å…‰æº
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            let p = boardData[r][c];
            if (p && p.type === TYPES.SOURCE) {
              light[r][c] = true;
              [0, 1, 2, 3].forEach((d) => rays.push({ r, c, dir: d, dist: 0 }));
            }
          }
        }

        const dr = [-1, 0, 1, 0]; // ä¸Š å³ ä¸‹ å·¦
        const dc = [0, 1, 0, -1];
        let visited = new Set(); // é˜²æ­¢å…‰è·¯æ­»å¾ªç¯

        // 2. å…‰çº¿ä¼ æ’­
        while (rays.length > 0) {
          let ray = rays.shift();

          // å‰ªæï¼šé˜²æ­¢æ— é™åå°„
          let key = `${ray.r},${ray.c},${ray.dir}`;
          if (visited.has(key) || ray.dist > 25) continue;
          visited.add(key);

          let nr = ray.r + dr[ray.dir];
          let nc = ray.c + dc[ray.dir];

          // è¶Šç•Œåœæ­¢
          if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE)
            continue;

          // è®°å½•å…‰æŸçº¿æ®µ (æ¸²æŸ“ç”¨)
          // åªæœ‰å½“è¿™æ˜¯çœŸå®è®¡ç®—è€ŒéAIæ¨¡æ‹Ÿæ—¶ï¼Œæˆ‘ä»¬æ‰å…³å¿ƒ beam æ•°ç»„
          // ä½†ä¸ºäº†é€šç”¨æ€§ï¼Œæˆ‘ä»¬è¿”å›å®ƒ
          beams.push({ x1: ray.c, y1: ray.r, x2: nc, y2: nr });
          light[nr][nc] = true;

          let hit = boardData[nr][nc];

          if (!hit) {
            // ç©ºæ°”
            rays.push({ r: nr, c: nc, dir: ray.dir, dist: ray.dist + 1 });
          } else {
            // å‡»ä¸­ç‰©ä½“
            if (hit.type === TYPES.PRISM) {
              // ç©¿é€
              rays.push({ r: nr, c: nc, dir: ray.dir, dist: ray.dist + 1 });
              // æŠ˜å°„ (90åº¦)
              rays.push({
                r: nr,
                c: nc,
                dir: (ray.dir + 1) % 4,
                dist: ray.dist + 1,
              });
              rays.push({
                r: nr,
                c: nc,
                dir: (ray.dir + 3) % 4,
                dist: ray.dist + 1,
              });
            }
            // å…¶ä»–ç‰©ä½“é˜»æŒ¡å…‰çº¿
          }
        }
        return { lightMap: light, beamPaths: beams };
      }

      // --- ç§»åŠ¨é€»è¾‘å¼•æ“ (å«è§„åˆ™åˆ¤æ–­) ---
      // è¿”å›æ‰€æœ‰åˆæ³•ç§»åŠ¨ {r, c, target}
      function getValidMoves(boardData, lightData, r, c) {
        let piece = boardData[r][c];
        if (!piece || piece.type === TYPES.RUIN) return [];

        let moves = [];
        let isLit = lightData[r][c];
        let owner = piece.owner;

        const add = (tr, tc) => {
          if (tr < 0 || tr >= BOARD_SIZE || tc < 0 || tc >= BOARD_SIZE) return;
          let target = boardData[tr][tc];

          // 1. ä¸èƒ½åƒè‡ªå·±äºº
          if (target && target.owner === owner) return;
          // 2. ä¸èƒ½åƒé—è¿¹
          if (target && target.type === TYPES.RUIN) return;
          // 3. æ ¸å¿ƒäº¤æ¢ç‰¹æƒ (v5.0): æ ¸å¿ƒå¯ä»¥å’Œå·±æ–¹çš„è™šç©º/æ£±é•œäº¤æ¢
          if (piece.type === TYPES.SOURCE && target && target.owner === owner) {
            if (target.type === TYPES.VOID || target.type === TYPES.PRISM) {
              moves.push({ r: tr, c: tc, type: "swap" }); // ç‰¹æ®Šç±»å‹
              return;
            }
          }

          // 4. å½±è¡Œè€…ä¿æŠ¤æœºåˆ¶ (v5.0):
          // å¦‚æœç›®æ ‡æ˜¯æš—å¤„çš„å½±è¡Œè€…ï¼Œä¸”æˆ‘æ–¹æ˜¯æ»‘è¡Œæ”»å‡»(è·ç¦»>1)ï¼Œåˆ™ä¸èƒ½é€‰ä½œç›®æ ‡
          if (target && target.type === TYPES.SHADOW) {
            let targetLit = lightData[tr][tc];
            if (!targetLit) {
              // å¦‚æœæ˜¯ç›¸é‚»æ ¼ï¼Œå…è®¸æ”»å‡» (è‚‰æ)
              let dist = Math.abs(tr - r) + Math.abs(tc - c);
              if (dist > 1) return; // è¿œç¨‹æ»‘è¡Œè¢«å…ç–«
            }
          }

          moves.push({ r: tr, c: tc, target: target });
        };

        const slide = (dirs) => {
          dirs.forEach((d) => {
            for (let i = 1; i < BOARD_SIZE; i++) {
              let nr = r + d[0] * i;
              let nc = c + d[1] * i;
              if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE)
                break;

              let hit = boardData[nr][nc];
              if (!hit) {
                add(nr, nc); // ç©ºåœ°
              } else {
                add(nr, nc); // æ’åˆ°ä¸œè¥¿ï¼Œå°è¯•æ”»å‡»
                break; // åœæ­¢
              }
            }
          });
        };

        const CROSS = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
        ];
        const DIAG = [
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1],
        ];
        const KING = [...CROSS, ...DIAG];
        const KNIGHT = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1],
        ];

        switch (piece.type) {
          case TYPES.SOURCE:
          case TYPES.VOID:
            KING.forEach((d) => add(r + d[0], c + d[1]));
            break;
          case TYPES.PRISM:
            slide(CROSS);
            break;
          case TYPES.GUARD:
            if (isLit) slide(CROSS); // å……èƒ½
            else KING.forEach((d) => add(r + d[0], c + d[1])); // æ²¡ç”µ
            break;
          case TYPES.SHADOW:
            if (!isLit) KNIGHT.forEach((d) => add(r + d[0], c + d[1])); // æ½œè¡Œ
            else CROSS.forEach((d) => add(r + d[0], c + d[1])); // æš´éœ²
            break;
        }

        return moves;
      }

      // --- AI å¼•æ“ (Deep Simulation) ---
      async function runAI() {
        if (state.gameOver) return;
        state.isAiBusy = true;
        updateUI();

        // ç¨å¾®å»¶è¿Ÿï¼Œé¿å…é˜»å¡ UI
        await new Promise((r) => setTimeout(r, 100));

        let bestScore = -Infinity;
        let bestMove = null;

        // 1. æ‰¾å‡ºæ‰€æœ‰å·±æ–¹æ£‹å­
        let myPieces = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (state.board[r][c] && state.board[r][c].owner === "blue") {
              myPieces.push({ r, c, piece: state.board[r][c] });
            }
          }
        }

        // 2. éå†æ‰€æœ‰å¯èƒ½ç§»åŠ¨
        for (let p of myPieces) {
          let moves = getValidMoves(state.board, state.lightMap, p.r, p.c);

          for (let m of moves) {
            // --- æ·±åº¦æ¨¡æ‹Ÿå¼€å§‹ ---
            // a. å¤‡ä»½æ£‹ç›˜
            let nextBoard = state.board.map((row) =>
              row.map((cell) => (cell ? { ...cell } : null))
            );

            // b. æ‰§è¡Œç§»åŠ¨
            let mover = nextBoard[p.r][p.c];
            nextBoard[p.r][p.c] = null;
            nextBoard[m.r][m.c] = mover; // åƒå­æˆ–ç§»åŠ¨

            // c. é‡æ–°è®¡ç®—ç§»åŠ¨åçš„å…‰ç…§ (å…³é”®ä¿®å¤!)
            let simResult = computeLight(nextBoard);

            // d. è¯„ä¼°å±€é¢
            let score = evaluateBoard(nextBoard, simResult.lightMap, "blue");

            // å¯å‘å¼åŠ åˆ†
            // æ”»å‡»åŠ åˆ†
            if (m.target) {
              if (m.target.type === TYPES.SOURCE) score += 99999;
              else if (m.target.type === TYPES.PRISM) score += 50;
              else score += 30;
            }

            // éšæœºæ‰°åŠ¨ (0-5åˆ†) é˜²æ­¢èµ°æ³•å•ä¸€
            score += Math.random() * 5;

            if (score > bestScore) {
              bestScore = score;
              bestMove = { from: { r: p.r, c: p.c }, to: { r: m.r, c: m.c } };
            }
          }
        }

        if (bestMove) {
          applyMove(
            bestMove.from.r,
            bestMove.from.c,
            bestMove.to.r,
            bestMove.to.c
          );
        } else {
          console.log("AI æ— è·¯å¯èµ°");
        }

        state.isAiBusy = false;
        updateUI();
      }

      function evaluateBoard(boardData, lightData, myColor) {
        let score = 0;
        let enemyColor = myColor === "red" ? "blue" : "red";

        // ç®€å•çš„æè´¨ä»·å€¼
        const VALUE = {
          [TYPES.SOURCE]: 1000,
          [TYPES.PRISM]: 60,
          [TYPES.GUARD]: 40,
          [TYPES.SHADOW]: 40,
          [TYPES.VOID]: 30,
          [TYPES.RUIN]: 0,
        };

        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            let p = boardData[r][c];
            if (!p || p.type === TYPES.RUIN) continue;

            let val = VALUE[p.type];
            let isLit = lightData[r][c];
            let isMe = p.owner === myColor;

            // åŸºç¡€åˆ†
            score += isMe ? val : -val;

            // çŠ¶æ€åŠ æˆ
            if (p.type === TYPES.GUARD) {
              // å…‰å«å–œæ¬¢å…‰
              if (isLit) score += isMe ? 20 : -20;
            }
            if (p.type === TYPES.SHADOW) {
              // å½±è¡Œè€…å–œæ¬¢æš—
              if (!isLit) score += isMe ? 25 : -25;
              // å¦‚æœå½±è¡Œè€…æš´éœ²åœ¨å…‰ä¸‹ï¼Œä¸”é è¿‘æ•Œäººï¼Œå¾ˆå±é™© (æ‰£åˆ†)
              if (isMe && isLit) score -= 30;
            }
            if (p.type === TYPES.SOURCE) {
              // æ ¸å¿ƒå‘¨å›´å¦‚æœæœ‰æ•Œäººå½±è¡Œè€…ï¼Œæåº¦å±é™©
              // è¿™é‡Œå¯ä»¥åŠ æ›´å¤šé€»è¾‘
            }
          }
        }
        return score;
      }

      // --- æ¸¸æˆæ§åˆ¶ ---
      function initGame() {
        state.board = Array(BOARD_SIZE)
          .fill(0)
          .map(() => Array(BOARD_SIZE).fill(null));
        state.gameOver = false;
        state.turn = "red";
        state.selected = null;
        state.lastMove = null;
        state.isAiBusy = false;

        // å¸ƒå±€ (v5.0 è°ƒæ•´)
        const add = (r, c, type, owner) =>
          (state.board[r][c] = { type, owner });

        // é—è¿¹
        [
          [5, 5],
          [3, 3],
          [3, 7],
          [7, 3],
          [7, 7],
        ].forEach(([r, c]) => add(r, c, TYPES.RUIN, "neutral"));

        // è“æ–¹
        add(0, 5, TYPES.SOURCE, "blue");
        add(1, 4, TYPES.PRISM, "blue");
        add(1, 6, TYPES.PRISM, "blue");
        add(2, 5, TYPES.PRISM, "blue");
        add(1, 3, TYPES.VOID, "blue");
        add(1, 7, TYPES.VOID, "blue");
        add(2, 2, TYPES.GUARD, "blue");
        add(2, 8, TYPES.GUARD, "blue");
        add(3, 4, TYPES.GUARD, "blue");
        add(3, 6, TYPES.GUARD, "blue");
        add(2, 1, TYPES.SHADOW, "blue");
        add(2, 9, TYPES.SHADOW, "blue");
        add(3, 2, TYPES.SHADOW, "blue");
        add(3, 8, TYPES.SHADOW, "blue");

        // çº¢æ–¹
        add(10, 5, TYPES.SOURCE, "red");
        add(9, 4, TYPES.PRISM, "red");
        add(9, 6, TYPES.PRISM, "red");
        add(8, 5, TYPES.PRISM, "red");
        add(9, 3, TYPES.VOID, "red");
        add(9, 7, TYPES.VOID, "red");
        add(8, 2, TYPES.GUARD, "red");
        add(8, 8, TYPES.GUARD, "red");
        add(7, 4, TYPES.GUARD, "red");
        add(7, 6, TYPES.GUARD, "red");
        add(8, 1, TYPES.SHADOW, "red");
        add(8, 9, TYPES.SHADOW, "red");
        add(7, 2, TYPES.SHADOW, "red");
        add(7, 8, TYPES.SHADOW, "red");

        refreshState();
        render();
        updateUI();
      }

      function refreshState() {
        // æ›´æ–°å…‰ç…§
        let res = computeLight(state.board);
        state.lightMap = res.lightMap;
        state.beams = res.beamPaths;
      }

      function onCellClick(r, c) {
        if (state.gameOver || state.isAiBusy) return;
        if (state.mode === "pve" && state.turn === "blue") return;

        let clicked = state.board[r][c];

        // 1. å°è¯•ç§»åŠ¨
        if (state.selected) {
          let moves = getValidMoves(
            state.board,
            state.lightMap,
            state.selected.r,
            state.selected.c
          );
          let validMove = moves.find((m) => m.r === r && m.c === c);

          if (validMove) {
            applyMove(state.selected.r, state.selected.c, r, c);
            return;
          }
        }

        // 2. é€‰æ‹©/å–æ¶ˆ
        if (clicked && clicked.owner === state.turn) {
          state.selected = { r, c };
          showInfo(clicked, state.lightMap[r][c]);
        } else {
          state.selected = null;
          hideInfo();
        }
        render();
      }

      function applyMove(fr, fc, tr, tc) {
        let piece = state.board[fr][fc];
        let target = state.board[tr][tc];

        // èƒœè´Ÿåˆ¤å®š
        if (target && target.type === TYPES.SOURCE) {
          endGame(piece.owner);
          return;
        }

        // ç§»åŠ¨æ•°æ®æ›´æ–°
        state.board[fr][fc] = null;
        state.board[tr][tc] = piece;
        state.lastMove = { fromR: fr, fromC: fc, toR: tr, toC: tc };

        // åˆ‡æ¢å›åˆ
        state.selected = null;
        state.turn = state.turn === "red" ? "blue" : "red";

        // åˆ·æ–°çŠ¶æ€
        refreshState();
        render();
        updateUI();

        // è§¦å‘AI
        if (state.mode === "pve" && state.turn === "blue" && !state.gameOver) {
          runAI();
        }
      }

      function endGame(winner) {
        state.gameOver = true;
        refreshState(); // ç¡®ä¿æœ€åä¸€å‡»çš„å…‰ç…§æ˜¯æ­£ç¡®çš„
        render();
        setTimeout(() => {
          alert(winner === "red" ? "ğŸ”´ çº¢æ–¹èƒœåˆ©ï¼" : "ğŸ”µ è“æ–¹èƒœåˆ©ï¼");
        }, 50);
      }

      // --- æ¸²æŸ“ç³»ç»Ÿ ---
      function render() {
        const boardEl = document.getElementById("board");
        const svgEl = document.getElementById("beam-layer");
        boardEl.innerHTML = "";
        svgEl.innerHTML = "";

        // 1. ç»˜åˆ¶æ¿€å…‰
        state.beams.forEach((b) => {
          const line = (c, w, op) => {
            let el = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );
            el.setAttribute("x1", b.x1 * CELL_PX + 25);
            el.setAttribute("y1", b.y1 * CELL_PX + 25);
            el.setAttribute("x2", b.x2 * CELL_PX + 25);
            el.setAttribute("y2", b.y2 * CELL_PX + 25);
            el.setAttribute("stroke", c);
            el.setAttribute("stroke-width", w);
            el.setAttribute("stroke-opacity", op);
            el.setAttribute("stroke-linecap", "round");
            return el;
          };
          svgEl.appendChild(line("var(--beam-glow)", 8, 0.3));
          svgEl.appendChild(line("var(--beam-core)", 2, 0.9));
        });

        // 2. ç»˜åˆ¶æ ¼å­
        let validMoves = state.selected
          ? getValidMoves(
              state.board,
              state.lightMap,
              state.selected.r,
              state.selected.c
            )
          : [];

        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            let cell = document.createElement("div");
            cell.className = "cell";
            if (state.lightMap[r][c]) cell.classList.add("lit");

            let p = state.board[r][c];

            // é—è¿¹çº¹ç†
            if (p && p.type === TYPES.RUIN) cell.classList.add("ruin");

            // ä¸Šä¸€æ­¥é«˜äº®
            if (
              state.lastMove &&
              ((state.lastMove.fromR === r && state.lastMove.fromC === c) ||
                (state.lastMove.toR === r && state.lastMove.toC === c))
            ) {
              cell.classList.add("last-move");
            }

            // æ£‹å­æ¸²æŸ“
            if (p && p.type !== TYPES.RUIN) {
              let pel = document.createElement("div");
              pel.className = `piece ${p.owner}`;
              if (
                state.selected &&
                state.selected.r === r &&
                state.selected.c === c
              )
                pel.classList.add("selected");
              pel.innerText = CONFIG[p.type].icon;
              cell.appendChild(pel);
            }

            // ç§»åŠ¨æ ‡è®°
            let vm = validMoves.find((m) => m.r === r && m.c === c);
            if (vm) {
              let mk = document.createElement("div");
              mk.className = `marker ${vm.target ? "attack" : "move"}`;
              cell.appendChild(mk);
            }

            cell.onclick = () => onCellClick(r, c);
            boardEl.appendChild(cell);
          }
        }
      }

      // --- UI æ›´æ–° ---
      function updateUI() {
        const t = document.getElementById("turn-text");
        const log = document.getElementById("ai-log");
        const btnPvp = document.getElementById("btn-pvp");
        const btnPve = document.getElementById("btn-pve");

        if (state.turn === "red") {
          t.innerText = "ğŸ”´ çº¢æ–¹å›åˆ";
          t.style.color = "var(--red-main)";
          log.style.display = "none";
        } else {
          t.innerText = "ğŸ”µ è“æ–¹å›åˆ";
          t.style.color = "var(--blue-main)";
          if (state.mode === "pve") {
            t.innerText += " (AI)";
            log.style.display = "block";
          }
        }

        btnPvp.className =
          state.mode === "pvp" ? "btn mode-btn" : "btn secondary mode-btn";
        btnPve.className =
          state.mode === "pve" ? "btn mode-btn" : "btn secondary mode-btn";
      }

      function showInfo(p, isLit) {
        const pan = document.getElementById("info-panel");
        pan.style.display = "block";
        pan.style.opacity = 1;

        document.getElementById("p-icon").innerText = CONFIG[p.type].icon;
        document.getElementById("p-name").innerText = CONFIG[p.type].name;
        document.getElementById("p-desc").innerText = CONFIG[p.type].desc;

        let stat = document.getElementById("p-status");
        stat.innerHTML = "";

        if (p.type === TYPES.GUARD) {
          stat.innerHTML = isLit
            ? '<span class="buff-tag buff-good">âš¡ å……èƒ½å®Œæ¯•</span>'
            : '<span class="buff-tag buff-bad">âš ï¸ èƒ½é‡æ¯ç«­</span>';
        } else if (p.type === TYPES.SHADOW) {
          stat.innerHTML = !isLit
            ? '<span class="buff-tag buff-good">ğŸ‘» æš—å½±æ½œè¡Œ</span>'
            : '<span class="buff-tag buff-bad">ğŸ‘ï¸ æš´éœ²è¡Œè¸ª</span>';
        }
      }

      function hideInfo() {
        document.getElementById("info-panel").style.opacity = 0;
      }

      function switchMode(m) {
        state.mode = m;
        initGame();
      }

      function resetGame() {
        initGame();
      }

      // å¯åŠ¨
      initGame();
    </script>
  </body>
</html>
