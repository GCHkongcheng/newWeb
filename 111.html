<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å…‰å½±æˆ˜æ£‹ v2.0 - æ¿€å…‰è§‰é†’</title>
    <style>
      :root {
        --bg-color: #121212;
        --panel-bg: #1e1e1e;
        --board-border: #444;
        --cell-base: #2a2a2a;
        --cell-lit: #3a3a3a; /* ç¨å¾®äº®ä¸€ç‚¹çš„èƒŒæ™¯ */
        --red-team: #ff5252;
        --blue-team: #448aff;
        --beam-color: rgba(255, 235, 59, 0.8);
        --beam-glow: 0 0 8px rgba(255, 235, 59, 0.6);
      }

      body {
        font-family: "Segoe UI", Roboto, sans-serif;
        background-color: var(--bg-color);
        color: #eee;
        display: flex;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      /* å¸ƒå±€å®¹å™¨ */
      .container {
        display: flex;
        width: 100%;
        height: 100%;
      }

      /* å·¦ä¾§æ¸¸æˆåŒº */
      .game-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
      }

      /* å³ä¾§ä¿¡æ¯é¢æ¿ */
      .sidebar {
        width: 300px;
        background-color: var(--panel-bg);
        padding: 20px;
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
      }

      h1 {
        margin: 0 0 20px 0;
        font-size: 22px;
        color: #fff;
        letter-spacing: 1px;
      }

      .status-card {
        background: #333;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .turn-badge {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 4px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .piece-info h3 {
        margin: 0 0 5px 0;
      }
      .piece-info p {
        margin: 5px 0;
        font-size: 14px;
        color: #aaa;
      }
      .buff-tag {
        display: inline-block;
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 4px;
        margin-top: 5px;
      }
      .buff-good {
        background: rgba(76, 175, 80, 0.2);
        color: #81c784;
        border: 1px solid #81c784;
      }
      .buff-bad {
        background: rgba(244, 67, 54, 0.2);
        color: #e57373;
        border: 1px solid #e57373;
      }

      /* æ£‹ç›˜å±‚å ç»“æ„ */
      .board-wrapper {
        position: relative;
        width: 540px; /* 9 * 60 */
        height: 540px;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(9, 60px);
        grid-template-rows: repeat(9, 60px);
        gap: 0;
        background-color: var(--board-border);
        border: 2px solid var(--board-border);
      }

      .cell {
        width: 60px;
        height: 60px;
        background-color: var(--cell-base);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 32px;
        cursor: pointer;
        position: relative;
        border: 1px solid #333;
        transition: background-color 0.2s;
        z-index: 2; /* åœ¨å…‰çº¿ä¹‹ä¸‹ï¼Œä½†åœ¨èƒŒæ™¯ä¹‹ä¸Š? ä¸ï¼Œå…‰çº¿éœ€è¦åœ¨æœ€ä¸Šå±‚ */
      }

      /* æ£‹ç›˜æ ¼æ ·å¼ */
      .cell:nth-child(odd) {
        background-color: #2e2e2e;
      }
      .cell:nth-child(even) {
        background-color: #2a2a2a;
      }
      .cell.lit {
        background-color: #353530 !important;
      } /* ææ·¡çš„é»„è‰²èƒŒæ™¯æç¤º */

      /* æ¿€å…‰å±‚ (SVG) */
      .beam-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        z-index: 5;
      }

      /* æ£‹å­å±‚ */
      .piece {
        z-index: 10;
        transition: transform 0.2s ease-out;
        user-select: none;
      }
      .piece.red {
        color: var(--red-team);
        filter: drop-shadow(0 0 2px black);
      }
      .piece.blue {
        color: var(--blue-team);
        filter: drop-shadow(0 0 2px black);
      }

      /* é€‰ä¸­çŠ¶æ€ */
      .cell.selected {
        box-shadow: inset 0 0 0 3px #fff;
      }
      .cell.valid-move::after {
        content: "";
        position: absolute;
        width: 12px;
        height: 12px;
        background-color: rgba(0, 255, 0, 0.6);
        border-radius: 50%;
        z-index: 20;
        animation: pulse 1.5s infinite;
      }
      .cell.valid-attack::after {
        background-color: rgba(255, 0, 0, 0.6);
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.3);
          opacity: 0.4;
        }
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
      }

      /* æŒ‰é’® */
      button {
        background: #333;
        color: white;
        border: 1px solid #555;
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 4px;
        margin-top: auto;
        font-size: 14px;
      }
      button:hover {
        background: #444;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="game-area">
        <div class="board-wrapper">
          <div class="board" id="board"></div>
          <svg class="beam-layer" id="beam-layer"></svg>
        </div>
      </div>

      <div class="sidebar">
        <h1>å…‰å½±æˆ˜æ£‹ v2.0</h1>

        <div class="status-card">
          <div
            id="turn-badge"
            class="turn-badge"
            style="background: var(--red-team)"
          >
            çº¢æ–¹å›åˆ
          </div>
          <div style="font-size: 13px; color: #888">å‡»æ€å¯¹æ–¹æ ¸å¿ƒ(â˜€ï¸)è·èƒœ</div>
        </div>

        <div
          class="status-card"
          id="selection-panel"
          style="display: none; border-left: 4px solid #fff"
        >
          <div class="piece-info">
            <h3 id="sel-name">æ£‹å­åç§°</h3>
            <p id="sel-desc">æ£‹å­æè¿°...</p>
            <div id="sel-buff" class="buff-tag">çŠ¶æ€</div>
          </div>
        </div>

        <div style="flex: 1"></div>
        <button onclick="initGame()">é‡æ–°å¼€å§‹æ¸¸æˆ</button>
      </div>
    </div>

    <script>
      // --- æ¸¸æˆå¸¸é‡ ---
      const BOARD_SIZE = 9;
      const CELL_SIZE = 60; // used for SVG coords
      const TYPES = {
        SOURCE: "source", // â˜€ï¸ æ ¸å¿ƒ
        PRISM: "prism", // ğŸ’ æ£±é•œ
        SHADOW: "shadow", // ğŸ¥· å½±è¡Œè€…
        GUARD: "guard", // ğŸ›¡ï¸ å…‰å«
        VOID: "void", // â¬› è™šç©ºå¢™
      };

      const PIECE_CONFIG = {
        [TYPES.SOURCE]: {
          icon: "â˜€ï¸",
          name: "å…‰æºæ ¸å¿ƒ",
          desc: "ä½ çš„ç”Ÿå‘½ã€‚å‘å››å‘¨å‘å°„å…‰çº¿ã€‚ç§»åŠ¨ï¼š1æ ¼(ç‹)ã€‚",
        },
        [TYPES.PRISM]: {
          icon: "ğŸ’",
          name: "æŠ˜å…‰æ£±é•œ",
          desc: "ä¸­ç»§ç«™ã€‚å…‰çº¿ç©¿é€å¹¶å‘ä¸¤ä¾§æŠ˜å°„ã€‚ç§»åŠ¨ï¼šç›´çº¿(è½¦)ã€‚",
        },
        [TYPES.SHADOW]: {
          icon: "ğŸ¥·",
          name: "å½±è¡Œè€…",
          desc: "åˆºå®¢ã€‚æš—å¤„ï¼šè·³è·ƒ(é©¬)ä¸”æ— æ•Œï¼›äº®å¤„ï¼šèµ°1æ ¼(å…µ)ä¸”è„†å¼±ã€‚",
        },
        [TYPES.GUARD]: {
          icon: "ğŸ›¡ï¸",
          name: "å…‰å«",
          desc: "æˆ˜å£«ã€‚äº®å¤„ï¼šå†²é”‹(è½¦)ä¸”æŠ¤ç”²ï¼›æš—å¤„ï¼šèµ°1æ ¼ã€‚",
        },
        [TYPES.VOID]: {
          icon: "â¬›",
          name: "è™šç©ºå¢™",
          desc: "å¦å…‹ã€‚åå™¬ä¸€åˆ‡å…‰çº¿ã€‚ç§»åŠ¨ï¼š1æ ¼ã€‚",
        },
      };

      let board = [];
      let lightMap = [];
      let turn = "red";
      let selectedPiece = null;

      // --- åˆå§‹åŒ– ---
      function initGame() {
        turn = "red";
        selectedPiece = null;
        createBoardData();
        updateGameState(); // è®¡ç®—å…‰ç…§ + æ¸²æŸ“
      }

      function createBoardData() {
        board = Array(BOARD_SIZE)
          .fill(null)
          .map(() => Array(BOARD_SIZE).fill(null));
        const place = (r, c, type, owner) => {
          board[r][c] = { type, owner, r, c, id: Math.random() };
        };

        // è“æ–¹ (ä¸Š)
        place(0, 4, TYPES.SOURCE, "blue");
        place(1, 3, TYPES.PRISM, "blue");
        place(1, 5, TYPES.PRISM, "blue");
        place(1, 4, TYPES.VOID, "blue");
        place(2, 2, TYPES.GUARD, "blue");
        place(2, 6, TYPES.GUARD, "blue");
        place(1, 1, TYPES.GUARD, "blue");
        place(2, 3, TYPES.SHADOW, "blue");
        place(2, 5, TYPES.SHADOW, "blue");
        place(2, 4, TYPES.SHADOW, "blue");

        // çº¢æ–¹ (ä¸‹)
        place(8, 4, TYPES.SOURCE, "red");
        place(7, 3, TYPES.PRISM, "red");
        place(7, 5, TYPES.PRISM, "red");
        place(7, 4, TYPES.VOID, "red");
        place(6, 2, TYPES.GUARD, "red");
        place(6, 6, TYPES.GUARD, "red");
        place(7, 7, TYPES.GUARD, "red");
        place(6, 3, TYPES.SHADOW, "red");
        place(6, 5, TYPES.SHADOW, "red");
        place(6, 4, TYPES.SHADOW, "red");
      }

      // --- æ ¸å¿ƒé€»è¾‘ï¼šå…‰ç…§è®¡ç®— + SVGç»˜åˆ¶æ•°æ®ç”Ÿæˆ ---
      function updateGameState() {
        calculateLight();
        renderBoard();
        renderBeams();
        updateUI();
      }

      // å­˜å‚¨å…‰æŸçº¿æ®µç”¨äºç»˜åˆ¶
      let beamSegments = [];

      function calculateLight() {
        lightMap = Array(BOARD_SIZE)
          .fill(false)
          .map(() => Array(BOARD_SIZE).fill(false));
        beamSegments = [];

        let sources = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] && board[r][c].type === TYPES.SOURCE) {
              sources.push({ r, c });
            }
          }
        }

        const dr = [-1, 0, 1, 0]; // ä¸Š å³ ä¸‹ å·¦
        const dc = [0, 1, 0, -1];

        let beams = [];
        sources.forEach((src) => {
          lightMap[src.r][src.c] = true;
          for (let i = 0; i < 4; i++)
            beams.push({ r: src.r, c: src.c, dir: i, depth: 0 });
        });

        let processed = new Set(); // é˜²æ­¢æ— é™å¾ªç¯

        while (beams.length > 0) {
          let b = beams.shift();

          // å”¯ä¸€é”®æ£€æŸ¥ï¼Œé˜²æ­¢åŒä¸€ä½ç½®åŒä¸€æ–¹å‘é‡å¤å¤„ç†
          let key = `${b.r},${b.c},${b.dir}`;
          if (processed.has(key) || b.depth > 20) continue;
          processed.add(key);

          let nr = b.r + dr[b.dir];
          let nc = b.c + dc[b.dir];

          // è®°å½•çº¿æ®µèµ·ç‚¹å’Œç»ˆç‚¹ (ç”¨äºSVG)
          // èµ·ç‚¹æ˜¯å½“å‰æ ¼ä¸­å¿ƒï¼Œç»ˆç‚¹æ˜¯ä¸‹ä¸€æ ¼ä¸­å¿ƒ
          // å¦‚æœå‡ºç•Œï¼Œç»ˆç‚¹æ˜¯è¾¹ç¼˜

          if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) {
            // å°„å‘è¾¹ç¼˜
            continue;
          }

          // è®°å½•å…‰æŸçº¿æ®µ (è§†è§‰)
          beamSegments.push({ r1: b.r, c1: b.c, r2: nr, c2: nc });

          lightMap[nr][nc] = true;
          let piece = board[nr][nc];

          if (!piece) {
            beams.push({ r: nr, c: nc, dir: b.dir, depth: b.depth });
          } else {
            if (piece.type === TYPES.PRISM) {
              beams.push({ r: nr, c: nc, dir: b.dir, depth: b.depth + 1 }); // ç›´å°„
              beams.push({
                r: nr,
                c: nc,
                dir: (b.dir + 1) % 4,
                depth: b.depth + 1,
              }); // å³è½¬
              beams.push({
                r: nr,
                c: nc,
                dir: (b.dir + 3) % 4,
                depth: b.depth + 1,
              }); // å·¦è½¬
            } else if (piece.type === TYPES.VOID) {
              // å¸æ”¶
            } else {
              // é˜»æŒ¡ (Source, Guard, Shadow)
            }
          }
        }
      }

      // --- ç§»åŠ¨é€»è¾‘ ---
      function getValidMoves(piece) {
        let moves = [];
        let r = piece.r,
          c = piece.c;
        let isLit = lightMap[r][c];

        const addMove = (tr, tc) => {
          if (tr >= 0 && tr < BOARD_SIZE && tc >= 0 && tc < BOARD_SIZE) {
            let target = board[tr][tc];
            // ä¸èƒ½åƒè‡ªå·±çš„ï¼Œé™¤éç‰¹æ®ŠæŠ€èƒ½(æš‚æ— )
            if (!target || target.owner !== piece.owner) {
              moves.push({ r: tr, c: tc, isAttack: !!target });
            }
          }
        };

        const slide = (dirs) => {
          dirs.forEach((d) => {
            for (let i = 1; i < BOARD_SIZE; i++) {
              let nr = r + d[0] * i;
              let nc = c + d[1] * i;
              if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE)
                break;
              let target = board[nr][nc];
              if (!target) {
                moves.push({ r: nr, c: nc });
              } else {
                if (target.owner !== piece.owner)
                  moves.push({ r: nr, c: nc, isAttack: true });
                break;
              }
            }
          });
        };

        const dirsCross = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
        ];
        const dirsKing = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1],
        ];
        const dirsKnight = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1],
        ];

        switch (piece.type) {
          case TYPES.SOURCE:
            // v2.0 ä¼˜åŒ–ï¼šæ ¸å¿ƒå¯ä»¥åƒç‹ä¸€æ ·ç§»åŠ¨ï¼Œé˜²æ­¢è¢«æ­»é”
            dirsKing.forEach((d) => addMove(r + d[0], c + d[1]));
            break;
          case TYPES.VOID:
            dirsKing.forEach((d) => addMove(r + d[0], c + d[1]));
            break;
          case TYPES.PRISM:
            slide(dirsCross);
            break;
          case TYPES.GUARD:
            if (isLit) slide(dirsCross);
            else dirsKing.forEach((d) => addMove(r + d[0], c + d[1]));
            break;
          case TYPES.SHADOW:
            if (!isLit) dirsKnight.forEach((d) => addMove(r + d[0], c + d[1]));
            else {
              // äº®å¤„åªèƒ½èµ°1æ ¼ï¼Œä¸”ä¸èƒ½æ”»å‡»(è¿™é‡Œç®€åŒ–ä¸ºèƒ½ç§»åŠ¨ä½†æå¼±)
              dirsCross.forEach((d) => addMove(r + d[0], c + d[1]));
            }
            break;
        }
        return moves;
      }

      // --- äº¤äº’ ---
      function handleClick(r, c) {
        let clickedPiece = board[r][c];
        const cell = document.querySelector(
          `.cell[data-r="${r}"][data-c="${c}"]`
        );

        // å°è¯•ç§»åŠ¨
        if (selectedPiece && cell.classList.contains("valid-move")) {
          executeMove(selectedPiece, r, c);
          return;
        }

        // é€‰æ‹©æ£‹å­
        if (clickedPiece && clickedPiece.owner === turn) {
          selectedPiece = clickedPiece;
          updateGameState(); // åˆ·æ–°é«˜äº®
          showSelectionInfo(clickedPiece);
        } else {
          selectedPiece = null;
          updateGameState();
          document.getElementById("selection-panel").style.display = "none";
        }
      }

      function executeMove(piece, tr, tc) {
        let target = board[tr][tc];
        if (target && target.type === TYPES.SOURCE) {
          alert((turn === "red" ? "çº¢æ–¹" : "è“æ–¹") + " è·èƒœï¼");
          initGame();
          return;
        }

        board[piece.r][piece.c] = null;
        piece.r = tr;
        piece.c = tc;
        board[tr][tc] = piece;

        selectedPiece = null;
        turn = turn === "red" ? "blue" : "red";
        updateGameState();
      }

      // --- æ¸²æŸ“ç³»ç»Ÿ ---
      function renderBoard() {
        const boardEl = document.getElementById("board");
        boardEl.innerHTML = "";

        let validMoves = selectedPiece ? getValidMoves(selectedPiece) : [];
        let validMap = new Set(validMoves.map((m) => `${m.r},${m.c}`));

        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            let cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.r = r;
            cell.dataset.c = c;

            // åœ°å½¢æç¤º
            if (lightMap[r][c]) cell.classList.add("lit");

            // æ£‹å­
            let piece = board[r][c];
            if (piece) {
              let pDiv = document.createElement("div");
              pDiv.className = `piece ${piece.owner}`;
              pDiv.innerText = PIECE_CONFIG[piece.type].icon;
              cell.appendChild(pDiv);
              if (selectedPiece === piece) cell.classList.add("selected");
            }

            // ç§»åŠ¨æç¤º
            if (validMap.has(`${r},${c}`)) {
              cell.classList.add("valid-move");
              if (piece) cell.classList.add("valid-attack"); // çº¢è‰²æç¤º
            }

            cell.onclick = () => handleClick(r, c);
            boardEl.appendChild(cell);
          }
        }
      }

      function renderBeams() {
        const svg = document.getElementById("beam-layer");
        svg.innerHTML = ""; // Clear

        // ç»˜åˆ¶å…‰æŸ
        beamSegments.forEach((seg) => {
          let line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          // è®¡ç®—ä¸­å¿ƒç‚¹åæ ‡
          let x1 = seg.c1 * CELL_SIZE + CELL_SIZE / 2;
          let y1 = seg.r1 * CELL_SIZE + CELL_SIZE / 2;
          let x2 = seg.c2 * CELL_SIZE + CELL_SIZE / 2;
          let y2 = seg.r2 * CELL_SIZE + CELL_SIZE / 2;

          line.setAttribute("x1", x1);
          line.setAttribute("y1", y1);
          line.setAttribute("x2", x2);
          line.setAttribute("y2", y2);
          line.setAttribute("stroke", "var(--beam-color)");
          line.setAttribute("stroke-width", "4");
          line.setAttribute("stroke-linecap", "round");
          line.style.filter = "drop-shadow(var(--beam-glow))";

          svg.appendChild(line);
        });

        // åœ¨å…‰æºå¤„ç»˜åˆ¶ä¸€ä¸ªå‘å…‰ç‚¹
        board.flat().forEach((p) => {
          if (p && p.type === TYPES.SOURCE) {
            let circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            circle.setAttribute("cx", p.c * CELL_SIZE + CELL_SIZE / 2);
            circle.setAttribute("cy", p.r * CELL_SIZE + CELL_SIZE / 2);
            circle.setAttribute("r", "10");
            circle.setAttribute("fill", "white");
            circle.style.filter = "drop-shadow(0 0 10px yellow)";
            svg.appendChild(circle);
          }
        });
      }

      function updateUI() {
        // æ›´æ–°å›åˆæç¤º
        const badge = document.getElementById("turn-badge");
        badge.innerText = turn === "red" ? "ğŸ”´ çº¢æ–¹å›åˆ" : "ğŸ”µ è“æ–¹å›åˆ";
        badge.style.background =
          turn === "red" ? "rgba(255, 82, 82, 0.2)" : "rgba(68, 138, 255, 0.2)";
        badge.style.color = turn === "red" ? "#ff5252" : "#448aff";
        badge.style.border = `1px solid ${
          turn === "red" ? "#ff5252" : "#448aff"
        }`;
      }

      function showSelectionInfo(piece) {
        const panel = document.getElementById("selection-panel");
        const name = document.getElementById("sel-name");
        const desc = document.getElementById("sel-desc");
        const buff = document.getElementById("sel-buff");
        const info = PIECE_CONFIG[piece.type];

        panel.style.display = "block";
        panel.style.borderColor =
          piece.owner === "red" ? "var(--red-team)" : "var(--blue-team)";
        name.innerText = info.icon + " " + info.name;
        desc.innerText = info.desc;

        let isLit = lightMap[piece.r][piece.c];

        // åŠ¨æ€çŠ¶æ€æè¿°
        if (piece.type === TYPES.GUARD) {
          buff.className = isLit ? "buff-tag buff-good" : "buff-tag buff-bad";
          buff.innerText = isLit
            ? "å……èƒ½ä¸­ï¼šåƒè½¦ä¸€æ ·å†²é”‹"
            : "å……èƒ½ä¸¢å¤±ï¼šåªèƒ½èµ°1æ ¼";
        } else if (piece.type === TYPES.SHADOW) {
          buff.className = !isLit ? "buff-tag buff-good" : "buff-tag buff-bad";
          buff.innerText = !isLit ? "æ½œè¡Œä¸­ï¼šåƒé©¬è·³è·ƒ" : "æš´éœ²ï¼šæåº¦è„†å¼±";
        } else if (piece.type === TYPES.SOURCE) {
          buff.className = "buff-tag buff-good";
          buff.innerText = "èƒ½é‡æºï¼šç”Ÿæˆå…‰çº¿";
        } else {
          buff.style.display = "none";
        }
        if (piece.type !== TYPES.PRISM && piece.type !== TYPES.VOID)
          buff.style.display = "inline-block";
      }

      // Start
      initGame();
    </script>
  </body>
</html>
